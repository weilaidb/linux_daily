config ARCH
	string
	option env="ARCH"

config KERNELVERSION
	string
	option env="KERNELVERSION"
	
config DEFCONFIG_LIST
	string
	depends on !UML
	option defconfig_list
	default "/lib/modules/$UNAME_RELEASE/.config"
	default "/etc/kernel-config"
	default "/boot/config-$UNAME_RELEASE"
	default "$ARCH_DEFCONFIG"
	default "arch/$ARCH/defconfig"
	
config CONSTRUCTORS
	bool
	depends on !UML
	
config IRQ_WORK
	bool
	depends on !UML
	
config BUILDTIME_EXTABLE_SORT
	bool
	
config THREAD_INFO_IN_TASK
	bool
	help
		Selects this to move thread_info off the stack into task_struct. To
		make this work, an arch will need to remove all thread_info fields
		except flags and fix any runtime bugs.
		
		One subtle chance that will be needed is to use try_get_task_stack()
		and put_task_stack() in save_thread_stack_tsk() and get_wchan().
	
menu "General setup"

config BROKEN
	bool
	
config BROKEN_ON_SMP
	bool
	depends on BROKEN || !SMP
	default y
	
config INIT_ENV_ARG_LIMIT
	int
	default 32 if !UML
	default 128 if UML
	help
		Maximum of each of the number of arguments and environment
		variables passed to init from the kernel command line.
		
config CROSS_COMPILE
	string "Cross-compiler tool prefix"
	help
		Same as running 'make CROSS_COMPILE=prefix-' but stored for
		default make runs in this kernel build directory. You don't
		need to set this unless you want the configured kernel build
		directory to select the cross-compiler automatically.

config COMPILE_TEST
	bool "Compile also drivers which will not load "
	depends on !UML
	default n
	help
		Some drivers can be compiled on a different platform than they are 
		intended to be run on. Despite they cannot be loaded there(or even
		when they load they cannot be used due to missing HW support),
		developers still, opposing to distributors, might want to build such
		drivers to compile-test them.
		
		If you are a developers and want to build everything available, say Y
		here. If you are a user/distributor, say N here to exclude useless
		drivers to be distribted
		
config LOCALVERSION
	string "Local version - append to kernel release "
	help
		Append an extra string to the end of your kernel version.
		This will show up when you type uname, for example.
		The string you set here will be appended after the contents of 
		any files with a filename matching localversion* in your
		object and source tree, in that order. Your total string can 
		be a maximum of 64 characters.
		
config LOCALVERSON_AUTO
	bool "Automatically append version information to the version string"
	default y
	depends on !COMPILE_TEST
	help
		This will try to automatically determine if the current tree is a 
		release tree by looking for git tags that belong to the current
		top of tree revision.
		
		A string of the format -gxxxxxxx will be added to the localversion
		if a git-based tree is founded. The string generated by this will be 
		appended after any matching localversion* files, and after the value 
		set in CONFIG_LOCALVERSION.
		
		(The actual string used here is the first eight characters produced
		by running the command:
		
			$git rev-parse--verify HEAD
		which is done within the script "scripts/setlocalversion".)

config HAVE_KERNEL_GZIP
	bool

config HAVE_KERNEL_BZIP2
	bool

config HAVE_KERNEL_LZMA
	bool
	
config HAVE_KERNEL_XZ
	bool
	
config HAVE_KERNEL_LZO
	bool
	
config HAVE_KERNEL_LZ4
	bool
	
choice
	prompt "Kernel compression mode"
	default KERNEL_GZIP
	depends on HAVE_KERNEL_GZIP || HAVE_KERNEL_BZIP2 || HAVE_KERNEL_LZMA || HAVE_KERNEL_XZ || HAVE_KERNEL_LZO || HAVE_KERNEL_LZ4
	help
		The linux kernel is a kind of self-extracting executable.
		Several compression algorithms are available, which difffer
		in efficiency, compression and decompression speed.
		Compression speed is only relevant when building a kernel.
		Decompression speed is relevant at each boot.
		
		If you have any problems with bzip2 or lzma compressed
		kernels, mail me (Alain Knaff) <alain@knaff.lu>.(An older
		version of this functionality(bzip2 only), for 2.4, was
		supplied by Christian Ludwing)
		
		High compression options are mostly useful for users, who
		are low on disk space(embedded systems), but for whom ram 
		size matters less.
		
		If in doubt, select 'gzip'
		
config KERNEL_GZIP
	bool "Gzip"
	depends on HAVE_KERNEL_GZIP
	help 
		The old and tried gzip compression. It provides a good balance
		between compression ratio and decompression speed.

config KERNEL_BZIP2
	bool "Bzip2"
	depends on HAVE_KERNEL_BZIP2
	help
		Its compression ratio and speed is intermediate.
		Decompression speed is slowest among the choices. The kernel
		size is about 10% smaller than bzip2, in comparison to gzip.
		Bzip2 uses a large amount of memory. For modern kernels you 
		will need at least 8MB RAM or more for booting.
		
config KERNEL_LZMA
	bool "LZMA"
	depends on HAVE_KERNEL_LZMA
	help 
		This compression algorithm's ratio is best. Decompression speed
		is between gzip and bzip2. Compression is slowest.
		The kernel size is about 33% smaller with LZMA in comparison to gzip.
		

config KERNEL_XZ
	bool "XZ"
	depends on HAVE_KERNEL_XZ
	help
		XZ uses the LZMA2 algorithm and instruction set specific
		BCJ filters which can improve compression ratio of executable
		code. The size of the kernel is about 30% smaller with XZ in comparison to 
		gzip. On architectures for which there is a BCJ
		filter(i386, x86_64, ARM, IA-64, PowerPC, and SPARC), XZ
		will creat a few percent smaller kernel than plain LZMA.
		
		The speed is about the same as with LZMA: The decompression
		speed of XZ is better than that of bzip2 but worse than gzip
		and LZO. Compression is slow.
		
	config KERNEL_LZO
		bool "LZO"
		depends on HAVE_KERNEL_LZO
		help
			Its compression ratio is the poorest among the choices. The kernel
			size is about 10% bigger than gzip; however its speed
			(both compression and decompression) is the fastest.
			
	config KERNEL_LZ4
		bool "LZ4"
		depends on HAVE_KERNEL_LZ4
		help
			LZ4 is an LZ77-type compressor with a fixed, byte-oriented encoding.
			A preliminary versoin of LZ4 de/compression tool is available at
			<https://code.google.com/p/lz4/>.
			
			Its compressed ratio is worse than LZO. The size of the kernel
			is about 8% bigger than LZO. But the decompression speed is 
			faster than LZO.
			
endchoice

config DEFAULT_HOSTNAME
	string "Default hostname"
	default "(none)"
	help
		This option determines the default system hostname before userspace 
		calls sethosename(2). The kernel traditionally uses "(none)" here,
		but you may wish to use a different default here to make a minimal 
		system more usable with less configuration.

config SWAP
	bool "Support for pagin of anonymous memory(swap)"
	depends on MMU && BLOCK
	default y
	help
		This option allows you to choose whether you want to have support
		for so called swap devices or swap files in your kernel that are 
		used to privide more virtual memory than the actual RAM present
		in your compute. If unusure say Y.
		
		
config SYSVIPC
	bool "System V IPC"
	---help---
		Inter Process Communication is a suite of libray functions and 
		system calls which let processes(running programs) synchronize and 
		exchange information.It is generally considered to be a good thing,
		and some programs won't run unless you say Y here. In particular, if 
		you want to run the DOS emulator dosemu under Linux(read the 
		DOSEMU-HOWTO, available from <http://www.tldp.org/docs.html#howto>),
		you'll need to say Y here.
		
		You can find documentation about IPC with "info ipc" and also in 
		section 6.4 of the Linux Programmer's Guide, available from
		<http://www.tldp.org/guides.html>.
		
config SYSVIPC_SYSCTL
	bool
	depends on SYSVIPC
	depends on SYSCTL
	default y
	
config POSIX_MQUEUE
	bool "POSIX Message Queues"
	depends on NET 
	---help---
	POSIX variant of message queues is a part of IPC.In POSIX message
	queues every message has a priority which decides about succession
	of receiving it by a process. If you want to compile and run 
	programs written e.g. for Solaris with use of its POSIX message
	queues(functions mq_*) say Y here.
	
	POSIX message queues are visible as  a filesystem called 'mqueue'
	and can  be mounted somewhere if you want to do filesystem
	operations on message queues.
	
	If unsure, say Y.
	
config POSIX_MQUEUE_SYSCTL
	bool
	depends on POSIX_MQUEUE
	depends on SYSCTL
	default y

	
config CROSS_MEMORY_ATTACH
	bool "Enable process_vm_readv/writev syscalls"
	depends on MMU 
	default y
	help
		Enabling this option adds the system calls process_vm_readv and 
		process_vm_writev which allow a process with the corrrect privileges 
		to directly read from or write to another process' address space.
		See the man page for more details.
		
config FHANDLE
	bool "open by fhandle syscalls" if EXPERT
	select EXPORTFS
	defaul y 
	help
		If you say Y here, a user level program will be able to map
		file names to handle and then laster use the handle for 
		different file system operations. This is useful in implementing 
		userspace file servers, which now track files using handles instead
		of names. The handle would remain the same even if file names 
		get renamed. Enables open_by_handle_at(2) and name_to_handle_at(2)
		syscalls.
		
config USELIB
	bool "uselib syscall"
	def_bool ALPHA || M68K || SPARC || X86_32 || IA32_EMULATION
	help 
		This option enables the uselib syscall, a system call used in the 
		dynamic linker from libc5 and earlier. glic does not use this 
		system call.  If you intend to run programs built on libc5 or
		earlier, you may need to enable this syscall. Current systems
		running glibc can safely disable this.
		


config AUDIT
	bool "Auditing support"
	depends on NET 
	help 
		Enable auditing infrastructure that can be used with another 
		kernel subsystem, such as SELinux(which requires this for 
		logging of avc messages output). System call auditing is included 
		on architectures which support it .
		
config HAVE_ARCH_AUDITSYSCALL
	bool 
	
config AUDITSYSCALL
	def_bool y 
	depends on AUDIT && HAVE_ARCH_AUDITSYSCALL
	
config AUDIT_WATCH
	def_bool y
	depends on AUDITSYSCALL
	select FSNOTIFY
	
config AUDIT_TREE
	def_bool y 
	depends on AUDITSYSCALL
	select FSNOTIFY
	
source "kernel/irq/Kconfig"
source "kernel/time/Kconfig"

menu "CPU/Task time and stats accounting"


config  VIRT_CPU_ACCOUTING
	bool

choice
	prompt "Cputime accounting"
	default TICK_CPU_ACCOUNTING if !PPC64
	default VIRT_CPU_ACCOUTING_NATIVE if PPC64
	
#Kind of a stub config for the pure tick based cputime accouting
config TICK_CPU_ACCOUNTING
	bool "Simple tick based cputime accouting"
	depends on !S390 && !NO_HZ_FULL
	help
		This is the basic tick based cputime accouting that maintains
		statistics about user, system and idle time spent on per jiffies 
		granularity.
		
		If unsure, say Y.
		
config VIRT_CPU_ACCOUNTING_NATIVE
	bool "Deterministic task and CPU time accounting"
	depends on HAVE_VIRT_CPU_ACCOUNTING && !NO_HZ_FULL
	select VIRT_CPU_ACCOUNTING
	help 
		Select this option to enable more accurate task and CPU time 
		accouting. This is done by read a CPU counter on each 
		kernel entry and exit and on transtions within the kernel
		between system, softirq and hardirq state, so there is a 
		small performance impact. In the case of s390 or IBM POWER > 5,
		this also enables accounting of stolen time on logically-partitioned
		systems.
		
config VIRT_CPU_ACCOUTING_GEN
	bool "Full dynticks CPU time accouting"
	depends on HAVE_CONTEXT_TRACKING
	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
	select VIRT_CPU_ACCOUNTING
	select CONTEXT_TRACKING
	help 
		Select  this option to enable task and CPU time accounting on full 
		dynticks systems. This accounting is implemented by watching every 
		kernel-user boundaries using the context tracking subsystem.
		The accounting is thus performed at the expense of some significant 
		overhead.
		
		For now this is only useful if you are working on the full 
		dynticks subsystem development.
		
		If unsure, say N.
endchoice


config IRQ_TIME_ACCOUNTING
	bool "Fine granularity task level IRQ time accouting"
	depends on HAVE_IRQ_TIME_ACCOUNTING && !VIRT_CPU_ACCOUNTING_NATIVE
	help 
		Select this option to enable fine granularity task irq time 
		accounting. This is done by reading a timestamp on each 
		transitions between softirq and hardirq state, so there can be a 
		small performance impact.
		
		If in doubt, say N here.
		
config BSD_PROCESS_ACCT
	bool "BSD Process Accounting"
	depends on MULTIUSER
	help 
		If you say Y here, a user level program will able to instruct the 
		kernel(via a special system call) to write process accounting 
		information to a file: whenever a process exits, information about 
		that process will be appended to the file by the kernel. The 
		that process will be appended to the file by the kernel. The 
		information includes things such as creation time, owning user,
		command name, memory usage, controlling terminal etc.(the complete
		list is in the struct acct in <file:include/linux/acct.h>). It is 
		up to the user level program to do useful things with this 
		information.  This is generally a good idea, so say Y.
		
		
config BSD_PROCESS_ACCT_V3
	bool "BSD Process Accounting versoin 3 file format"
	depends on BSD_PROCESS_ACCT
	default n
	help 
		If you say Y here, the process accounting information is written
		in a new file format that also logs the process IDs of each 
		process and it's partent. Note that this file format is incompatible
		with previos v0/v1/v2 file formats, so you will need updated tools 
		for processing it. A preliminary version of these tools is available 
		at <http://www.gnu.org/software/acct/ >.
		
config TASKSTATS
	bool "Export task/process statistics through netlink"
	depends on NET
	depends on MULTIUSER
	default n 
	help 
		Export selected statistics for tasks/processes through the 
		generic netlink interface. Unlike BSD process accounting, the 
		statistics are available during the lifetime of tasks/processes as 
		responses to commands. Like BSD accounting, they are sent to user 
		space on task exit.
		
		Say N if unsure.
		

config TASK_DELAY_ACCT
	bool "Enable per-task delay accounting"
	depends on TASKSTATS
	select SCHED_INFO
	help
		Collect information on time spent by a task waiting for system
		resources like cpu, synchronous block I/O completion and swapping
		in pages. Such statistics can help in setting a task's priorites
		relative to other tasks for cpu, io, rss limits etc.
		
		Say N if unsure.
		
config TASK_XACCT
	bool "Enable extended accounting over taskstats"
	depends on TASKSTATS
	help
		Collect extended task accounting data and send the data 
		to userland for processing over the taskstats interface.
		
	Say N if unsure.
	
	
config TASK_IO_ACCOUNTING
	bool "Enable per-task storage I/O accounting"
	depends on TASK_XACCT
	help
		Collect information on the number of bytes of storage I/O which this 
		task has caused.
		
		Say N if unsure.
		
endmenu # "CPU/Task time and stats accounting"

source "kernel/rcu/Kconfig"
		
config BUILD_BIN2C
	bool
	default n
	
	









































































































